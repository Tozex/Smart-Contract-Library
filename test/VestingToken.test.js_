const { BN, constants, expectEvent, time, expectRevert, ether } = require('@openzeppelin/test-helpers');
const { ZERO_ADDRESS } = constants;

const { expect } = require('chai');

const AccessControls = artifacts.require('AccessControls');
const DbitToken = artifacts.require('DbitToken');
const VestingToken = artifacts.require('VestingToken');

contract('Vesting Token Test', function ([owner, random, masterWallet, admin, smartContract, test, investor]) {

    const tokenSupply = new BN('100000000000000000000000000');
    const ONE_HUNDRED_TOKENS = new BN('100000000000000000000');
    const TWO_HUNDRED_TOKENS = new BN('200000000000000000000');
    const TEN_TOKENS = new BN('10000000000000000000');
    const REMAINING_TOKENS = new BN('99000000000000000000');
    const Thirty_days = new BN('2592000');
    const Fourty_days = new BN('3456000');
    const Sixty_days = new BN('5184000');
    const Seventy_days = new BN('6048000');
    beforeEach(async function () {
        this.accessControls = await AccessControls.new({from: owner});

        this.token = await DbitToken.new(this.accessControls.address, masterWallet, {from: owner});

        this.vestingContract = await VestingToken.new(this.token.address, this.accessControls.address, false, {from: owner});
    });

    describe('add pool', function () {
        it('revert once sender is not admin', async function () {
            await expectRevert(this.vestingContract.add(0, 20, 10, {from : random}), "VestingToken.add: Sender must be admin");
        });

        it('add success', async function () {
            await this.vestingContract.add(0, 20, 10, {from : owner});
            expect(await this.vestingContract.lockPoolLength()).to.be.bignumber.equal('1');
        });

        it('add 2 pools', async function () {
            await this.vestingContract.add(0, 20, 10, {from : owner});
            await this.vestingContract.add(1000, 20, 10, {from : owner});
            expect(await this.vestingContract.lockPoolLength()).to.be.bignumber.equal('2');
        });
    });

    describe('set pool', function () {
        beforeEach(async function () {
            await this.vestingContract.add(0, 20, 10, {from : owner});
        });

        it('revert once sender is not admin', async function () {
            await expectRevert(this.vestingContract.set(0, 100, 200, 10, {from : random}), "VestingToken.set: Sender must be admin");
        });

        it('set success', async function () {
            await this.vestingContract.set(0, 100, 200, 10, {from : owner});
            expect(await this.vestingContract.lockPoolLength()).to.be.bignumber.equal('1');

            const pool1 = await this.vestingContract.lockPool(0);
            expect(pool1.lockTime).to.be.bignumber.equal('100');
            expect(pool1.firstUnlock).to.be.bignumber.equal('200');
            expect(pool1.unlockPerMonth).to.be.bignumber.equal('10');
        });
    });
    
    describe('deposit', function () {
        beforeEach(async function () {
            await this.accessControls.addAdminRole(admin);
            await this.accessControls.addSmartContractRole(smartContract);
            await this.vestingContract.add(0, 20, 10, {from : owner});
        });

        it('revert once sender is not admin or smart contract', async function () {
            await expectRevert(this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : test}), "VestingToken.deposit: Sender must be admin or smart contract");
        });

        it('revert once investor is zero address', async function () {
            await expectRevert(this.vestingContract.deposit(0, ZERO_ADDRESS, ONE_HUNDRED_TOKENS, {from : admin}), "VestingToken.deposit: Deposit user address should not be zero address");
        });

        it('revert becuase insufficient token balance', async function () {
            await this.token.approve(this.vestingContract.address, ONE_HUNDRED_TOKENS, {from: admin});
            await expectRevert(this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : admin}), "ERC20: transfer amount exceeds balance");
        });

        context('deposit success', async function () {
            it('deposit from admin role', async function () {
                await this.token.transfer(admin, ONE_HUNDRED_TOKENS, {from: masterWallet});
                await this.token.approve(this.vestingContract.address, ONE_HUNDRED_TOKENS, {from: admin});
                await this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : admin});
                const userDetail = await this.vestingContract.userDetail(0, investor);
                expect(userDetail.totalRewardAmount).to.be.bignumber.equal(ONE_HUNDRED_TOKENS);
                expect(userDetail.withdrawAmount).to.be.bignumber.equal('0');
                expect(await this.token.balanceOf(this.vestingContract.address)).to.be.bignumber.equal(ONE_HUNDRED_TOKENS);
            }); 
            
            it('deposit from smart contract role', async function () {
                await this.token.transfer(smartContract, ONE_HUNDRED_TOKENS, {from: masterWallet});
                await this.token.approve(this.vestingContract.address, ONE_HUNDRED_TOKENS, {from: smartContract});
                await this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : smartContract});
                const userDetail = await this.vestingContract.userDetail(0, investor);
                expect(userDetail.totalRewardAmount).to.be.bignumber.equal(ONE_HUNDRED_TOKENS);
                expect(userDetail.withdrawAmount).to.be.bignumber.equal('0');
                expect(await this.token.balanceOf(this.vestingContract.address)).to.be.bignumber.equal(ONE_HUNDRED_TOKENS);
            }); 

            it('deposit from smart contract role', async function () {
                await this.token.transfer(smartContract, TWO_HUNDRED_TOKENS, {from: masterWallet});
                await this.token.approve(this.vestingContract.address, TWO_HUNDRED_TOKENS, {from: smartContract});
                await this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : smartContract});
                let userDetail = await this.vestingContract.userDetail(0, investor);
                expect(userDetail.totalRewardAmount).to.be.bignumber.equal(ONE_HUNDRED_TOKENS);
                expect(userDetail.withdrawAmount).to.be.bignumber.equal('0');
                expect(await this.token.balanceOf(this.vestingContract.address)).to.be.bignumber.equal(ONE_HUNDRED_TOKENS);

                await this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : smartContract});
                userDetail = await this.vestingContract.userDetail(0, investor);
                expect(userDetail.totalRewardAmount).to.be.bignumber.equal(TWO_HUNDRED_TOKENS);
                expect(userDetail.withdrawAmount).to.be.bignumber.equal('0');
                expect(await this.token.balanceOf(this.vestingContract.address)).to.be.bignumber.equal(TWO_HUNDRED_TOKENS);
            }); 
        });
    });

    describe('revoke', function () {
        beforeEach(async function () {
            await this.accessControls.addAdminRole(admin);
            await this.accessControls.addSmartContractRole(smartContract);
            await this.vestingContract.add(0, 20, 10, {from : owner});
            await this.token.transfer(smartContract, ONE_HUNDRED_TOKENS, {from: masterWallet});
            await this.token.approve(this.vestingContract.address, ONE_HUNDRED_TOKENS, {from: smartContract});
            await this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : smartContract});
        });

        it('revert once sender is not admin', async function () {
            await expectRevert(this.vestingContract.revoke(0, investor, {from : test}), "VestingToken.revoke: Sender must be admin");
        });

        it('revert once sender is not admin', async function () {
            await expectRevert(this.vestingContract.revoke(0, investor, {from : smartContract}), "VestingToken.revoke: Sender must be admin");
        });

        it('revert once investor is zero address', async function () {
            await expectRevert(this.vestingContract.revoke(0, ZERO_ADDRESS, {from : admin}), "VestingToken.revoke: User address should not be zero address");
        });

        it('revoke success', async function () {
            await this.vestingContract.revoke(0, investor, {from : admin});
            const userDetail = await this.vestingContract.userDetail(0, investor);
            expect(userDetail.totalRewardAmount).to.be.bignumber.equal('0');
            expect(userDetail.withdrawAmount).to.be.bignumber.equal('0');
            expect(userDetail.depositTime).to.be.bignumber.equal('0');
            expect(await this.token.balanceOf(this.vestingContract.address)).to.be.bignumber.equal('0');
        }); 
    });

    describe('updateTokenPublished', function () {
        beforeEach(async function () {
            await this.accessControls.addAdminRole(admin);
            await this.accessControls.addSmartContractRole(smartContract);
        });

        it('revert once sender is not admin', async function () {
            await expectRevert(this.vestingContract.updateTokenPublished(true, {from : test}), "VestingToken.updateTokenPublished: Sender must be admin");
        });

        it('revert once sender is not admin', async function () {
            await expectRevert(this.vestingContract.updateTokenPublished(true, {from : smartContract}), "VestingToken.updateTokenPublished: Sender must be admin");
        });

        it('updateTokenPublished success', async function () {
            let tokenPublished = await this.vestingContract.isTokenPublished();
            expect(tokenPublished).to.be.equal(false);

            await this.vestingContract.updateTokenPublished(true, {from : admin});

            tokenPublished = await this.vestingContract.isTokenPublished();
            expect(tokenPublished).to.be.equal(true);
        }); 
    });

    describe('unlockedToken', function () {
        beforeEach(async function () {
            await this.accessControls.addAdminRole(admin);
            await this.accessControls.addSmartContractRole(smartContract);
            await this.vestingContract.add(Thirty_days, 20, 10, {from : owner});
            await this.token.transfer(smartContract, ONE_HUNDRED_TOKENS, {from: masterWallet});
            await this.token.approve(this.vestingContract.address, ONE_HUNDRED_TOKENS, {from: smartContract});
            await this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : smartContract});
        });

        it('should be 0 before token published', async function () {
            let unlockedAmount = await this.vestingContract.unlockedToken(0, investor);
            expect(unlockedAmount).to.be.bignumber.equal('0');
        }); 

        it('should be 0 before lock time passed', async function () {
            await this.vestingContract.updateTokenPublished(true, {from : admin});
            let unlockedAmount = await this.vestingContract.unlockedToken(0, investor);
            expect(unlockedAmount).to.be.bignumber.equal('0');
        }); 

        it('should be firstUnlock percent of deposit token once locktime passed', async function () {
            await this.vestingContract.updateTokenPublished(true, {from : admin});
            await time.increase(Thirty_days);
            const pool = await this.vestingContract.lockPool(0);
            const userDetail = await this.vestingContract.userDetail(0, investor);
            const firstUnlockedAmount = userDetail.totalRewardAmount.mul(new BN(pool.firstUnlock)).div(new BN('100')); 
            let unlockedAmount = await this.vestingContract.unlockedToken(0, investor);
            expect(unlockedAmount).to.be.bignumber.equal(firstUnlockedAmount);
        }); 

        it('should be firstUnlock percent of deposit token before 1 month passed', async function () {
            await this.vestingContract.updateTokenPublished(true, {from : admin});
            await time.increase(Fourty_days);
            const pool = await this.vestingContract.lockPool(0);
            const userDetail = await this.vestingContract.userDetail(0, investor);
            const firstUnlockedAmount = userDetail.totalRewardAmount.mul(new BN(pool.firstUnlock)).div(new BN('100')); 
            let unlockedAmount = await this.vestingContract.unlockedToken(0, investor);
            expect(unlockedAmount).to.be.bignumber.equal(firstUnlockedAmount);
        }); 

        it('after 2 month passed', async function () {
            await this.vestingContract.updateTokenPublished(true, {from : admin});
            await time.increase(Sixty_days);
            const pool = await this.vestingContract.lockPool(0);
            const userDetail = await this.vestingContract.userDetail(0, investor);
            const _unlockedAmount = userDetail.totalRewardAmount.mul(new BN(pool.firstUnlock).add(new BN(pool.unlockPerMonth))).div(new BN('100')); 
            let unlockedAmount = await this.vestingContract.unlockedToken(0, investor);
            expect(unlockedAmount).to.be.bignumber.equal(_unlockedAmount);
        }); 

        it('once user withdraw some amount', async function () {
            await this.vestingContract.updateTokenPublished(true, {from : admin});
            await time.increase(Sixty_days);
            const pool = await this.vestingContract.lockPool(0);
            const userDetail = await this.vestingContract.userDetail(0, investor);
            const _unlockedAmount = userDetail.totalRewardAmount.mul(new BN(pool.firstUnlock).add(new BN(pool.unlockPerMonth))).div(new BN('100')); 
            let unlockedAmount = await this.vestingContract.unlockedToken(0, investor);
            expect(unlockedAmount).to.be.bignumber.equal(_unlockedAmount);
            
            await this.vestingContract.withdrawToken(0, TEN_TOKENS, {from: investor});
            unlockedAmount = await this.vestingContract.unlockedToken(0, investor);
            expect(unlockedAmount).to.be.bignumber.equal(_unlockedAmount.sub(TEN_TOKENS));
        }); 
    });
    
    describe('withdrawToken', function () {
        beforeEach(async function () {
            await this.accessControls.addAdminRole(admin);
            await this.accessControls.addSmartContractRole(smartContract);
            await this.vestingContract.add(Thirty_days, 20, 10, {from : owner});
            await this.token.transfer(smartContract, ONE_HUNDRED_TOKENS, {from: masterWallet});
            await this.token.approve(this.vestingContract.address, ONE_HUNDRED_TOKENS, {from: smartContract});
            await this.vestingContract.deposit(0, investor, ONE_HUNDRED_TOKENS, {from : smartContract});
        });

        it('revert becuase token not published yet', async function () {
            await expectRevert(this.vestingContract.withdrawToken(0, TEN_TOKENS, {from : investor}), "VestingToken.withdrawToken: Token not published yet.");
        }); 
        
        it('revert becuase insufficient reward token amount', async function () {
            await this.vestingContract.updateTokenPublished(true, {from : admin});
            await expectRevert(this.vestingContract.withdrawToken(0, TEN_TOKENS, {from : investor}), "VestingToken.withdrawToken: Not enough token to withdraw.");
        }); 

        it('revert becuase insufficient reward token amount', async function () {
            await this.vestingContract.updateTokenPublished(true, {from : admin});
            await time.increase(Sixty_days);
            await expectRevert(this.vestingContract.withdrawToken(0, ONE_HUNDRED_TOKENS, {from : investor}), "VestingToken.withdrawToken: Not enough token to withdraw.");
        }); 
        
        it('withdraw success', async function () {
            await this.vestingContract.updateTokenPublished(true, {from : admin});
            await time.increase(Sixty_days);
            const pool = await this.vestingContract.lockPool(0);
            const userDetail = await this.vestingContract.userDetail(0, investor);
            const _unlockedAmount = userDetail.totalRewardAmount.mul(new BN(pool.firstUnlock).add(new BN(pool.unlockPerMonth))).div(new BN('100')); 
            await this.vestingContract.withdrawToken(0, TEN_TOKENS, {from: investor});
            expect(await this.token.balanceOf(investor)).to.be.bignumber.equal(TEN_TOKENS);
            unlockedAmount = await this.vestingContract.unlockedToken(0, investor);
            expect(unlockedAmount).to.be.bignumber.equal(_unlockedAmount.sub(TEN_TOKENS));
        }); 
    });
});
